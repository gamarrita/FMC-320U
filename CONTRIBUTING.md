# CONTRIBUTING

Este archivo documenta los cambios en el proyecto FMC-320U.


## Convenciones de nombres de ramas

UtilizÃ¡ los siguientes prefijos para indicar el propÃ³sito de cada rama:

| Prefijo       | PropÃ³sito                                             | Ejemplo                        |
|---------------|-------------------------------------------------------|--------------------------------|
| `main`        | CÃ³digo estable listo para producciÃ³n                  | -                              |
| `develop`     | IntegraciÃ³n de funcionalidades antes de la liberaciÃ³n | -                              |
| `feature/`    | Desarrollo de nuevas funcionalidades                  | `feature/eco-mode`             |
| `bugfix/`     | CorrecciÃ³n de errores menores                         | `bugfix/led-flicker`           |
| `hotfix/`     | CorrecciÃ³n urgente en producciÃ³n                      | `hotfix/fix-reboot-issue`      |
| `refactor/`   | ReestructuraciÃ³n del cÃ³digo sin cambiar funcionalidades | `refactor/init-logic`        |
| `test/`       | Pruebas o experimentos                                | `test/lptim3-capture`          |
| `release/`    | PreparaciÃ³n de una versiÃ³n para liberaciÃ³n            | `release/1.1.9-beta`           |

Nota 1: en la rama main solamente se deberian en equipos de desarrollos de varias personas, desde la 

Nota 1 (DHS): en equipos de desarrollos de varias personas, desde la 

## Convencion nombres de commits:
- `feat`: Nueva funcionalidad
- `fix`: CorrecciÃ³n de errores
- `refactor`: ReestructuraciÃ³n del cÃ³digo
- `test`: AdiciÃ³n o modificaciÃ³n de pruebas
- `docs`: Cambios en la documentaciÃ³n
- `chore`: Tareas menores o mantenimiento

## Ejemplo de fluho de trabajo

# Flujo de trabajo para versiones beta y finales (Git Flow adaptado)

Este documento describe el flujo completo para preparar una versiÃ³n `beta` y una versiÃ³n final (`stable`) siguiendo un modelo similar a Git Flow, usando las ramas `develop`, `release` y `main`.

---

## Se crea una desde devlop

La rama que puede ser feature/xyz, release/xyz, ... etc.
En un proyecto grande quizas varios desarrolladores esten desarrollando varios features al mismo tiempo, uno a uno hace merge a develop, luego se crea una rama release.
Para este proyecto se puede crear la rama release directamente.

## Fase de testeo (versiÃ³n beta)

EstÃ¡s en la rama: `release/01.01.009-beta` (en nuestro caso ya con varios commits)

1. RealizÃ¡s pruebas fÃ­sicas y ajustes en la rama `release/01.01.009-beta`.
2. ActualizÃ¡s parcialmente el archivo `CHANGELOG.md`.
3. HacÃ©s un commit con esos cambios.
4. CreÃ¡s un tag **beta**:

   ```bash
   git tag -a v01.01.009-beta -m "VersiÃ³n beta 01.01.009 para pruebas fÃ­sicas"
   git push origin v01.01.009-beta
   ```

> Este tag se utiliza para compartir con testers o implementar en entornos de prueba (staging).

---

## âœ… PreparaciÃ³n de la versiÃ³n final (estable)

5. RealizÃ¡s los Ãºltimos ajustes tras el testeo beta.
6. CompletÃ¡s el `CHANGELOG.md` con la informaciÃ³n definitiva.
7. HacÃ©s un commit final, por ejemplo: `chore: versiÃ³n estable 01.01.009`.
8. CreÃ¡s el tag **estable**:

   ```bash
   git tag -a v01.01.009 -m "VersiÃ³n estable 01.01.009"
   git push origin v01.01.009
   ```

> El tag puede hacerse en esta etapa **en la rama `release`** si estÃ¡s seguro del commit final, o bien en `main` despuÃ©s del merge. Ambas opciones son vÃ¡lidas (ver secciÃ³n mÃ¡s abajo).

---

## ğŸ”€ Cierre de la release: orden correcto de merges

9. MergeÃ¡s la rama `release/01.01.009-beta` en `main`:

   ```bash
   git checkout main
   git merge release/01.01.009-beta
   ```

   > Este paso marca oficialmente la publicaciÃ³n de la versiÃ³n final.

10. MergeÃ¡s la misma rama en `develop`:

   ```bash
   git checkout develop
   git merge release/01.01.009-beta
   ```

   > AsÃ­ `develop` queda actualizado con los Ãºltimos fixes aplicados durante el ciclo de release.

11. EliminÃ¡s la rama `release` (opcional):

   ```bash
   git branch -d release/01.01.009-beta           # local
   git push origin --delete release/01.01.009-beta  # remoto
   ```

---

## ğŸ“Œ Â¿DÃ³nde conviene crear el tag de versiÃ³n final?

Ambas opciones son vÃ¡lidas, segÃºn el contexto de tu proyecto.

### OpciÃ³n 1: **Tag en la rama `release` (antes del merge)**

```bash
git checkout release/01.01.009-beta
git tag -a v01.01.009 -m "VersiÃ³n estable 01.01.009"
```

- Recomendado si seguÃ­s Git Flow clÃ¡sico.
- El commit taggeado se verÃ¡ reflejado tambiÃ©n en `main` luego del merge (si es fast-forward).

### OpciÃ³n 2: **Tag en la rama `main` (despuÃ©s del merge)**

```bash
git checkout main
git tag -a v01.01.009 -m "VersiÃ³n estable 01.01.009"
```

- Ãštil si tu despliegue a producciÃ³n ocurre **solo desde `main`**.
- Garantiza que el tag estÃ¡ exactamente en la rama de producciÃ³n.

---

## ğŸ“˜ Ejemplo de `CHANGELOG.md`

```markdown
# Changelog

Todas las versiones importantes del proyecto se documentan aquÃ­.

## [Unreleased]

### Added
- (Pendiente de futuras funcionalidades)

---

## [01.01.009-beta] - 2025-05-05

### Added
- Validaciones visuales en equipo durante el testeo fÃ­sico.
- Prueba de integraciÃ³n general del firmware.
- Mejoras menores en presentaciÃ³n de versiÃ³n.

### Changed
- Estructura del changelog actualizada.

---

## [01.01.009] - 2025-05-10

### Added
- Correcciones tras testeo de campo.
- Validaciones finales integradas.
```

---

Este flujo es flexible y puede adaptarse a distintos modelos de desarrollo, pero asegura claridad, trazabilidad y control en tus entregas.


TenÃ©s que crear un nuevo tag?
SÃ­, deberÃ­as.
Cada tag representa un snapshot especÃ­fico, asÃ­ que si cambia el cÃ³digo, el tag debe cambiar para no generar confusiÃ³n.

ğŸ¤” Â¿CÃ³mo versionarlo? Â¿Y quÃ© pasa con 01.01.009?
OpciÃ³n A: seguir usando el mismo nÃºmero con sufijos beta
Si aÃºn estÃ¡s dentro del mismo ciclo de versiÃ³n 01.01.009, podÃ©s usar:

v01.01.009-beta.1

v01.01.009-beta.2

v01.01.009-beta.3

...

v01.01.009 (versiÃ³n final)

âœ… Esto es lo recomendado. AsÃ­ mantenÃ©s la coherencia: todos esos tags son parte del mismo ciclo de release 01.01.009.

OpciÃ³n B: saltar directamente a 01.01.010-beta
Esto se harÃ­a solo si decidÃ­s abandonar completamente la versiÃ³n 01.01.009.

ğŸ”´ Pero: si nunca existiÃ³ v01.01.009 final, entonces quedarÃ­a como un ciclo incompleto. TÃ©cnicamente vÃ¡lido, pero poco prolijo.

âœ… RecomendaciÃ³n profesional
Si el bug fue encontrado durante la fase beta y todavÃ­a no se hizo merge a main ni se publicÃ³ una final estable, lo mejor es:

bash
Copy
Edit
git tag -a v01.01.009-beta.2 -m "Segunda beta con correcciÃ³n de bug"
Y cuando estÃ© todo bien:

bash
Copy
Edit
git tag -a v01.01.009 -m "VersiÃ³n estable 01.01.009"
